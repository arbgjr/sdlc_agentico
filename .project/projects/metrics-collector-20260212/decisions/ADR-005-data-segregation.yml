---
# Architecture Decision Record
# Generated by: adr-author
# Phase: 3 (Architecture)
# Date: 2026-02-12T20:52:17Z

decision:
  id: "ADR-005"
  title: "Data Segregation Strategy Between Enterprises"
  status: "accepted"
  created_at: "2026-02-12T20:52:17Z"
  created_by: "system-architect"
  project: "metrics-collector-20260212"
  phase: 3

  context: |
    O sistema coleta dados de 2 GitHub Enterprise Cloud organizations.

    Requisitos de segregacao:
    1. Dados de cada enterprise devem ser identificaveis
    2. Queries podem filtrar por enterprise ou agregar
    3. PowerBI deve conseguir segmentar por enterprise
    4. Futuro: suportar mais enterprises sem refatoracao

    Opcoes avaliadas:
    - Schema-per-enterprise (PostgreSQL schemas)
    - Column-based segregation (coluna enterprise_id em todas tabelas)
    - Database-per-enterprise (bancos separados)
    - Tenant isolation (row-level security)

  decision: |
    Usar **Column-based segregation** com coluna `enterprise_id`.

    Implementacao:
    ```sql
    -- Todas as tabelas terao:
    enterprise_id VARCHAR(50) NOT NULL,

    -- Exemplo:
    CREATE TABLE copilot_metrics (
      id SERIAL PRIMARY KEY,
      enterprise_id VARCHAR(50) NOT NULL,
      org_name VARCHAR(100) NOT NULL,
      collected_at TIMESTAMP NOT NULL,
      metric_date DATE NOT NULL,
      -- ... outras colunas

      INDEX idx_enterprise_date (enterprise_id, metric_date)
    );
    ```

    Valores de enterprise_id:
    - Usar slug do enterprise (ex: "empresa-a", "empresa-b")
    - Configuravel via variavel de ambiente

  rationale: |
    **Por que Column-based sobre Schema-per-enterprise:**

    1. **Simplicidade de queries**: JOINs entre enterprises sao triviais
       - Schema-per-enterprise: `enterprise_a.copilot_metrics JOIN enterprise_b.copilot_metrics`
       - Column-based: `WHERE enterprise_id IN ('a', 'b')`

    2. **PowerBI friendly**: Uma unica conexao, filtro por coluna
       - Schema-per-enterprise requer multiplas conexoes ou UNION
       - Filtro de coluna e nativo no PowerBI

    3. **Flexibilidade**: Adicionar enterprise = adicionar valor na coluna
       - Sem DDL changes
       - Sem novas conexoes

    4. **Indexacao eficiente**: Index composto (enterprise_id, date)
       - Performance equivalente a schema separado
       - PostgreSQL otimiza bem filtros de coluna

    **Por que NAO Schema-per-enterprise:**
    - Complexidade de queries cross-enterprise
    - Cada novo enterprise = novo schema + migrations
    - PowerBI precisaria de conexoes multiplas ou views

    **Por que NAO Database-per-enterprise:**
    - Overengineering para 2 enterprises
    - Custo dobrado de infraestrutura
    - Complexidade operacional alta

    **Por que NAO Row-Level Security (RLS):**
    - RLS e para multi-tenant com isolamento de acesso
    - Nosso caso: mesmo usuario acessa todos os dados
    - Complexidade sem beneficio

  consequences:
    positive:
      - Queries simples com filtro WHERE
      - Uma conexao PowerBI serve todos os dados
      - Adicionar enterprise nao requer DDL
      - Reports cross-enterprise sao triviais
    negative:
      - Todos os dados na mesma tabela (pode crescer)
      - Sem isolamento fisico (mesmo storage)
      - Index deve incluir enterprise_id para performance
    mitigations:
      - "Particionamento por enterprise_id se volume crescer muito"
      - "Backup pode ser filtrado por enterprise se necessario"

  alternatives_considered:
    - option: "Schema-per-enterprise"
      rejected_because: "Complexidade de queries e PowerBI connections"

    - option: "Database-per-enterprise"
      rejected_because: "Overengineering, custo dobrado"

    - option: "Row-Level Security"
      rejected_because: "Nao ha requisito de isolamento de acesso"

  implementation:
    steps:
      - "Adicionar coluna enterprise_id em todas as tabelas"
      - "Criar index composto (enterprise_id, metric_date)"
      - "Configurar enterprise_id via environment variable"
      - "Documentar valores validos de enterprise_id"
    estimated_effort: "1-2 horas"

    schema_example:
      copilot_metrics:
        - "id SERIAL PRIMARY KEY"
        - "enterprise_id VARCHAR(50) NOT NULL"
        - "org_name VARCHAR(100) NOT NULL"
        - "metric_date DATE NOT NULL"
        - "active_users INTEGER"
        - "acceptance_rate DECIMAL(5,2)"
        - "collected_at TIMESTAMP DEFAULT NOW()"

      indexes:
        - "CREATE INDEX idx_copilot_enterprise_date ON copilot_metrics(enterprise_id, metric_date)"

  validation:
    criteria:
      - "Queries filtram por enterprise_id corretamente"
      - "PowerBI consegue segmentar por enterprise"
      - "Performance aceitavel com 2 enterprises"
      - "Adicionar 3o enterprise nao requer DDL"

  data_governance:
    enterprise_ids:
      - "enterprise-1"  # Nome a definir
      - "enterprise-2"  # Nome a definir
    naming_convention: "lowercase-slug"
    configuration: "GITHUB_ENTERPRISE_IDS environment variable"

  references:
    - title: "PostgreSQL Table Partitioning"
      url: "https://www.postgresql.org/docs/current/ddl-partitioning.html"
    - title: "Multi-tenant Data Architecture"
      url: "https://docs.microsoft.com/azure/architecture/guide/multitenant/considerations/data"

  tags:
    - "data-architecture"
    - "segregation"
    - "multi-tenant"
    - "postgresql"
