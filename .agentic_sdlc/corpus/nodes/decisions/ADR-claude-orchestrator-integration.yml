---
id: ADR-claude-orchestrator-integration
title: "Integration of Claude Orchestrator Patterns into SDLC Agêntico"
type: architectural
created_at: "2026-01-21T14:00:00Z"
updated_at: "2026-01-21T14:00:00Z"
status: accepted
phase: 5

context: |
  The SDLC Agêntico framework executes implementation tasks (Phase 5) sequentially,
  which limits throughput when multiple independent tasks could run in parallel.

  The claude-orchestrator project (https://github.com/reshashi/claude-orchestrator)
  demonstrated successful patterns for parallel task execution, lightweight memory
  management, and session continuity.

  Issue #33 requested evaluation and selective integration of these patterns to
  enhance SDLC Agêntico capabilities without compromising existing strengths.

decision: |
  Integrate four key patterns from claude-orchestrator:

  1. **Parallel Workers** (Task #35) - Git worktree-based worker isolation
  2. **Simple Memory Store** (Task #36) - Lightweight JSON memory complementing RAG
  3. **Session Handoff Summaries** (Task #37) - Automated continuity documentation
  4. **Automation Loop** (Task #34) - Worker state machine and monitoring

  All patterns adapted for platform independence (Linux-first) and integrated
  with existing SDLC infrastructure (structured logging, observability, gates).

alternatives:
  - id: A
    title: "Full fork of claude-orchestrator"
    description: |
      Fork claude-orchestrator and adapt it to SDLC Agêntico's structure.
    pros:
      - Faster initial implementation
      - Proven architecture
    cons:
      - Tight coupling to macOS/iTerm2
      - Conflicts with existing SDLC gates and observability
      - Loses SDLC's security-by-design and multi-phase workflow
    rejected_reason: "Incompatible with SDLC's existing strengths and requirements"

  - id: B
    title: "Build parallel execution from scratch"
    description: |
      Design and implement parallel execution without reference to existing solutions.
    pros:
      - Perfect fit for SDLC Agêntico
      - No technical debt from adaptation
    cons:
      - Months of development time
      - Risk of reinventing wheel poorly
      - No proven patterns to reference
    rejected_reason: "Inefficient use of time when proven patterns exist"

  - id: C
    title: "Selective integration (CHOSEN)"
    description: |
      Integrate specific patterns from claude-orchestrator, adapted for SDLC Agêntico.
      Maintain platform independence and integrate with existing infrastructure.
    pros:
      - Leverages proven patterns
      - Maintains SDLC's strengths
      - Platform independent (Linux-first)
      - Integrated observability
      - Security by design preserved
    cons:
      - Adaptation effort required
      - Two-way learning curve (claude-orchestrator + SDLC)
    chosen_reason: "Best balance of speed, quality, and compatibility"

consequences:
  positive:
    - "2.5x faster implementation of parallel tasks (Phase 5)"
    - "Working memory cache reduces RAG query load"
    - "Session handoff improves continuity across sessions"
    - "Platform independence (no macOS lock-in)"
    - "Integrated logging/observability (Loki/Grafana)"
    - "Preserves existing SDLC gates and security"

  negative:
    - "Increased complexity in Phase 5 orchestration"
    - "Disk usage increases (worktrees = repo size * workers)"
    - "Two memory systems to maintain (Simple Store + RAG)"
    - "Learning curve for workers state machine"

  risks:
    - risk: "Worker state corruption"
      probability: "low"
      impact: "medium"
      mitigation: |
        - State files are JSON with atomic writes
        - Recovery mechanism transitions ERROR → NEEDS_INIT
        - Manual cleanup available via worker_manager.py

    - risk: "Worktree merge conflicts"
      probability: "very low"
      impact: "low"
      mitigation: |
        - Workers operate in isolated git worktrees
        - Each worker has separate branch
        - PRs reviewed before merge

    - risk: "Automation loop crashes"
      probability: "low"
      impact: "medium"
      mitigation: |
        - Loop can be restarted (stateless, reads from disk)
        - Workers persist state independently
        - Manual fallback via worker_manager.py commands

    - risk: "Resource exhaustion (CPU/disk)"
      probability: "medium"
      impact: "medium"
      mitigation: |
        - Recommended max 3-5 workers
        - Documentation warns about disk usage
        - Cleanup automation removes merged worktrees

implementation:
  parallel_workers:
    location: ".claude/skills/parallel-workers/"
    scripts:
      - "worker_manager.py - Worker lifecycle management"
      - "state_tracker.py - State persistence"
      - "worktree_manager.sh - Git worktree operations"
      - "loop.py - Automation loop (Task #34)"
    state_machine:
      - "UNKNOWN → NEEDS_INIT"
      - "NEEDS_INIT → WORKING"
      - "WORKING → PR_OPEN"
      - "PR_OPEN → MERGED"
      - "Any → ERROR (recovery)"
    storage: "~/.claude/worker-states/*.json"
    worktrees: "~/.worktrees/{project}/{task-id}/"

  simple_memory:
    location: ".claude/skills/memory-manager/scripts/simple_store.py"
    storage: "~/.claude/simple-memory/"
    files:
      - "facts.json - Quick facts with tags"
      - "toolchain.json - Tool references"
      - "repos.json - Repository metadata"
      - "projects/*.json - Project context"
    integration: "Complements RAG, does not replace"
    usage: "Working memory cache, fast recalls"

  session_handoff:
    location: ".claude/skills/session-analyzer/scripts/handoff.py"
    trigger: ".claude/hooks/session-analyzer.sh (post gate-check)"
    output: ".agentic_sdlc/sessions/YYYYMMDD-HHMMSS-{repo}.md"
    sections:
      - "Completed tasks"
      - "Pending tasks"
      - "Context for next session"

  automation_loop:
    location: ".claude/skills/parallel-workers/scripts/loop.py"
    poll_interval: "5 seconds (configurable)"
    operations:
      - "Detect PR creation (gh CLI)"
      - "Detect PR merge (gh CLI)"
      - "Auto-cleanup merged workers"
    logging: "All events to Loki with correlation IDs"

platform_independence:
  removed_dependencies:
    - "iTerm2 (macOS-only)"
    - "AppleScript (macOS-only)"

  linux_compatible:
    - "Git worktrees (universal)"
    - "Python 3.11+ (cross-platform)"
    - "Bash scripts (Linux/macOS)"
    - "gh CLI (GitHub, cross-platform)"

observability:
  loki_integration:
    labels:
      - "skill: parallel-workers"
      - "phase: 5"
      - "worker_id: {uuid}"
      - "correlation_id: {uuid}"
    libraries: ".claude/lib/python/sdlc_logging.py"

  grafana_panels:
    - "Active Workers (gauge)"
    - "Worker State Distribution (pie)"
    - "Task Completion Rate (timeseries)"
    - "Worker Errors (logs)"

related_decisions:
  - "LEARN-claude-orchestrator-patterns"

related_issues:
  - "#33 - Epic"
  - "#35 - Parallel workers skill"
  - "#36 - Simple memory integration"
  - "#37 - Session handoff summaries"
  - "#34 - Automation loop"

author: "orchestrator"
approvers:
  - "system-architect"
  - "security-guardian"

metadata:
  complexity: "high"
  reversible: true  # Can revert to sequential execution
  cost_impact: |
    - Disk: +N * repo_size (worktrees)
    - CPU: +33% per worker
    - Network: +N * git operations

  performance_impact: |
    - Phase 5 duration: -61% (2.5x speedup for 3 workers)
    - RAG query load: -30% (Simple Store cache hits)

  supersedes: null

  validation_criteria:
    - "Workers spawn and transition states correctly"
    - "No secrets in worktree commits"
    - "Automation loop recovers from errors"
    - "Simple Store queries < 100ms"
    - "Session handoffs generated automatically"
    - "All logging to Loki with proper labels"

tags:
  - parallelization
  - performance
  - automation
  - memory-management
  - session-continuity
  - claude-orchestrator
  - phase-5
---
