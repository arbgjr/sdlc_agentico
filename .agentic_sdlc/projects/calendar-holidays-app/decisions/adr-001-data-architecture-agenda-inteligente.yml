decision:
  id: "adr-001"
  type: "architectural"
  title: "Arquitetura de Dados para Agenda Inteligente (Room + Firestore)"
  created_at: "2026-01-13T18:30:00Z"
  status: "accepted"

  context: |
    Precisamos definir uma arquitetura de dados robusta para um app Android de
    agenda inteligente com as seguintes características:

    - Offline-first (funcionar 100% sem internet)
    - Sincronização automática com cloud quando online
    - Suporte a alarmes recorrentes com categorias
    - Integração com feriados (API externa)
    - Gerenciamento de períodos de férias
    - Histórico de confirmações de medicamentos
    - Proteção de dados PII (LGPD/GDPR compliant)
    - Performance em dispositivos low-end

    Entidades principais:
    - User (perfil, localização, preferências)
    - AlarmCategory (categorias customizáveis)
    - Alarm (alarmes com recorrência complexa)
    - Vacation (períodos de férias)
    - Holiday (cache de feriados)
    - MedicationLog (histórico de confirmações)

  decision: |
    Implementar arquitetura híbrida com:

    1. **Room (SQLite) como storage local primário**
       - Offline-first: app funciona sem internet
       - Todas as entidades replicadas localmente
       - Índices otimizados para queries frequentes
       - Soft delete (deletedAt) para preservar histórico

    2. **Firestore como backend cloud**
       - Sincronização bidirecional (two-way sync)
       - Estrutura hierárquica (users/{userId}/alarms)
       - Security Rules para isolamento por usuário
       - Composite indexes para queries complexas

    3. **Estratégia de sincronização**
       - Last-write-wins com timestamps (updatedAt)
       - Sync triggers: app start, user action, periodic (15min), network available
       - Conflict resolution: timestamp mais recente vence
       - Retry policy: exponential backoff (3 tentativas)
       - Fields de controle: updatedAt, syncedAt, deletedAt

    4. **Criptografia de dados PII**
       - AES-256-GCM para campos sensíveis
       - Android Keystore para gerenciamento de chaves
       - Campos criptografados: name, email, city, destination
       - Key rotation a cada 90 dias

    5. **Cache de feriados**
       - TTL de 365 dias
       - Renovação automática anual
       - Tabela local + collection global no Firestore
       - Backend pode atualizar (users apenas leitura)

    6. **Performance optimization**
       - Pagination (20 items por página)
       - Lazy loading de detalhes
       - Índices compostos em queries frequentes
       - Debounce de 300ms em searches

  consequences:
    positive:
      - "App funciona 100% offline (melhor UX)"
      - "Sincronização transparente e automática"
      - "Dados protegidos com criptografia AES-256"
      - "Escalável (Firestore suporta milhões de usuários)"
      - "Backup automático no cloud"
      - "Histórico completo de confirmações"
      - "Performance em dispositivos low-end (queries otimizadas)"
      - "Compliance LGPD/GDPR (PII criptografado)"

    negative:
      - "Complexidade de implementação (sync logic)"
      - "Overhead de manter duas camadas de storage"
      - "Custos do Firestore (leituras/escritas/storage)"
      - "Necessidade de testar conflict resolution"
      - "Key rotation aumenta complexidade"

    risks:
      - "Conflitos de sincronização se timestamps incorretos"
      - "Perda de dados se encryption keys perdidas"
      - "Custos do Firestore podem crescer com escala"
      - "Complexidade de debug (local vs cloud)"

  alternatives_considered:
    - alternative: "Room + Firebase Realtime Database"
      rejected_reason: "Firestore tem melhor suporte offline e queries complexas"

    - alternative: "Room + REST API backend"
      rejected_reason: "Firestore oferece sync automático e SDK robusto"

    - alternative: "Apenas cloud (Firestore only)"
      rejected_reason: "Não atende requisito offline-first"

    - alternative: "SQLite puro sem sync"
      rejected_reason: "Não oferece backup/cross-device sync"

  related_decisions: []

  phase: 3

  author: "data-architect"

  approvers:
    - "system-architect"
    - "security-engineer"

  metadata:
    complexity: "high"
    reversible: false
    cost_impact: "Custos do Firestore (~$25-50/mês para 10k usuários ativos)"
    migration_effort: "Alta (requer implementação completa do sync layer)"

  implementation_notes:
    - "Implementar Room entities primeiro (base estável)"
    - "Adicionar encryption layer antes de armazenar PII"
    - "Implementar sync logic com testes extensivos"
    - "Configurar Firestore Security Rules antes de produção"
    - "Monitorar custos do Firestore (alertas no Firebase Console)"
    - "Documentar troubleshooting de sync conflicts"

  references:
    - title: "Room Persistence Library"
      url: "https://developer.android.com/training/data-storage/room"

    - title: "Firestore Offline Data"
      url: "https://firebase.google.com/docs/firestore/manage-data/enable-offline"

    - title: "Android Keystore System"
      url: "https://developer.android.com/training/articles/keystore"

    - title: "Firestore Security Rules"
      url: "https://firebase.google.com/docs/firestore/security/get-started"

  tags:
    - "android"
    - "room"
    - "firestore"
    - "offline-first"
    - "sync"
    - "encryption"
    - "data-architecture"
